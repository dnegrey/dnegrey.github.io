{
  "hash": "d63e22f832aecf3b6c3f1523b7f5c6d0",
  "result": {
    "markdown": "---\ntitle: \"Git Fundamentals\"\ndate: \"2017-03-16\"\ndescription: \"This post provides an overview of Git as a version control system\nand introduces the basic command line tools for use in a local project.\"\ncategories: [git, command line, version control]\nimage: \"image.jpg\"\n---\n\n\nOf all the tools I use as a data scientist, the one that I cherish the most is\n**[Git](https://git-scm.com/)**. As a free and open source *distributed* version\ncontrol system, Git plays an integral role in my work by seamlessly fostering\nmany of the most important considerations of data science workflows including\n**collaboration**, **experimentation**, **reproducibility** and of course,\n**source code management**.\n\nAt their core, version control systems (VCS) all serve one broad and common\npurpose: *tracking changes to files*. What distinguishes one system from\nanother, however, is *how* that purpose is implemented and what additional\nfeatures are present. To get a better understanding of the history and evolution\nof version control systems, I recommend reading the introduction at [Ry's Git\nTutorial](http://rypress.com/tutorials/git/index). You might also want to\nbookmark his tutorial and work your way through all of the sections as he does a\nterrific job demonstrating Git's feature set in much greater detail than what\nI'm covering in this post.\n\nBefore we move on, let's clarify something that often comes up when people first\nstart learning about Git. Many of you may have heard of companies like\n[GitHub](https://github.com/), [GitLab](https://about.gitlab.com/) or\n[Bitbucket](https://bitbucket.org/). These are each examples of *web-based\nrepository hosting services*. Git itself is just a lightweight command line\ntool. Services like GitHub provide software development platforms that center\naround the use of Git but add a rich suite of additional features. The focus of\nthis post is on learning the fundamentals of the Git command line tool.\n\n## Prerequisites\n\nA basic understanding of Linux (Unix-like) commands is assumed. Specifically,\nthis post makes extensive use of the following:\n\n* `mkdir`: create new directories\n* `cd`: change the current working directory\n* `echo`: display a line of text\n* `cat`: concatenate files and print on the standard output\n* `ls`: list directory contents\n* `rm`: remove files or directories\n\nFor brevity, I am using `echo` with redirection (`>`) to write files. In\nreality, you'd be using a visual editor such as `vi` to write and edit files.\n\n## Create a Local Git Repository\n\nBefore we can do anything with Git, we must initialize a directory as a Git\nrepository. Let's do so in a brand new directory that we'll create called\n`fundamentals` underneath our home directory (`~`):\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd ~\nmkdir fundamentals\ncd fundamentals\ngit init\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nInitialized empty Git repository in /home/dan/fundamentals/.git/\n```\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n## Add a README File\n\nThe first thing you'll want to do with any new Git repository is add a\n**README.md** file to the project root. As a plain text file, it will be the\neasiest place to save and read notes about your project. The \".md\" extension\nindicates that it is a [markdown](https://daringfireball.net/projects/markdown/)\nfile. Markdown is a text-to-HTML conversion tool that allows you to create\neasy-to-read and easy-to-write plain text files which get converted to HTML.\nHosting services like GitHub and GitLab will automatically render your README.md\nfile to HTML at the main repository site (for example:\n[https://github.com/rstudio/blogdown](https://github.com/rstudio/blogdown)).\nHere is a brief primer on some of the more commonly used markdown syntax:\n\n----------\n\n<div>\n<div style=\"float: left; width: 48%; margin-left: 0; margin-right: 2%;\">\n\n### **Headers**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# is an h1 header\n## is an h2 header\n### is an h3 header (and so on)\n```\n:::\n\n\n### **Regular Writing**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nRegular writing becomes a <p> tag\n```\n:::\n\n\n### **Inline Code**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nEnclose inline code in `single ticks`\n```\n:::\n\n\n### **Unordered Lists**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n* item one in unordered list\n* item two in unordered list\n* item three in unordered list\n```\n:::\n\n\n</div>\n<div style=\"float: right; width: 48%; margin-left: 2%; margin-right: 0;\">\n\n### **Italics and Bold**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n*italics*\n**bold**\n***bold-and-italics***\n```\n:::\n\n\n### **Hyperlinks**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n[hyperlink-alt-text](hyperlink-href)\n```\n:::\n\n\n### **Code Chunks**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n    Indent four spaces for a code block\n```\n:::\n\n\n### **Ordered Lists**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n1 item one in ordered list\n2 item two in ordered list\n3 item three in ordered list\n```\n:::\n\n\n</div>\n<br style=\"clear:both;\"/>\n</div>\n\n----------\n\nNow let's actually create our README.md file. A popular convention (and one that\nI use) is to have the first line of your README.md file be an `<h1>` header with\nthe name of your repository:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho \\# fundamentals > README.md\ncat README.md\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n# fundamentals\n```\n:::\n:::\n\n\n## Git Status\n\nNow that we actually have a file in our repository, we are ready to use Git. The\none command that you'll find yourself using regularly in order to check the\nstatus of your project and see what changes have occurred since the last \"clean\"\nstate is `git status`:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\n\nNo commits yet\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tREADME.md\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n:::\n:::\n\n\nNotice the response from our command. It lists our README.md file as an\n*untracked file*. This is Git's way of telling you that a new file is present in\nthe repository. It also says to use `\"git add\"` to track.\n\n## Staging\n\nGit allows you to review your changes before they get recorded into version\ncontrol. This is called **staging**. You can add or remove files from the\ncurrent staging area (\"snapshot\") using `git add` and `git rm`:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add README.md\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n\tnew file:   README.md\n```\n:::\n:::\n\n\nNow, README.md is being tracked and is ready to be *committed* into version\ncontrol.\n\n## Git Commit\n\nWhen you are ready to officially record (\"commit\") your staged changes, use the\n`git commit` command. Doing so will prompt you for a commit message (all commits\nget accompanied by a message), however, you can avoid the prompt and supply the\nmessage with the commit by using the `-m` option:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit commit -m \"initial commit\"\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n[main (root-commit) 33276a2] initial commit\n 1 file changed, 1 insertion(+)\n create mode 100644 README.md\nOn branch main\nnothing to commit, working tree clean\n```\n:::\n:::\n\n\nThis will commit any staged files. Note that each commit is given a unique\nidentifer known as a **SHA-1 hash**.\n\n## Git Log\n\nUse the `git log` command to print a summary of all the commits that you've\nmade. This will include the full commit hash, author, date and message. For an\nabbreviated result, use the `--oneline` option which will only print out the\ncommit message and the first 7 characters from the commit hash:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ncommit 33276a2309d5b5347a72754220d7fdf3320617ca\nAuthor: Dan Negrey <dnegrey@gmail.com>\nDate:   Tue Feb 7 20:51:18 2023 -0500\n\n    initial commit\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n33276a2 initial commit\n```\n:::\n:::\n\n\n## .gitignore\n\nThere may be instances when you want Git to ignore certain files in your\nrepository. A good example of this includes working data files that your code\nproduces while it is executing. Generally, if you subscribe to the principles of\nreproducible research, then you should be able to ignore any ouput files that\nyour code produces as your code should be able to reproduce the output when\nneeded. For Git to ignore certain files, you'll need to create a `.gitignore`\nfile in your project root, and list in it the file names or patterns that\ndescribe what is to be ignored.\n\nLet's confirm a clean working directory:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\npwd\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n/home/dan/fundamentals\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nls -l\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ntotal 4\n-rw-r--r-- 1 dan dan 15 Feb  7 20:51 README.md\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\nnothing to commit, working tree clean\n```\n:::\n:::\n\n\nNow, let's create a few data files that we'll want to ignore:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nfor i in 1 2 3; do\n    touch data${i}.csv\ndone\nls -l\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ntotal 4\n-rw-r--r-- 1 dan dan  0 Feb  7 20:51 data1.csv\n-rw-r--r-- 1 dan dan  0 Feb  7 20:51 data2.csv\n-rw-r--r-- 1 dan dan  0 Feb  7 20:51 data3.csv\n-rw-r--r-- 1 dan dan 15 Feb  7 20:51 README.md\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tdata1.csv\n\tdata2.csv\n\tdata3.csv\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n:::\n:::\n\n\nNext, we simply create our `.gitignore` file with the correct pattern to ignore\nthese new data files:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho data\\*.csv > .gitignore\ncat .gitignore\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ndata*.csv\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.gitignore\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nls -la\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ntotal 20\ndrwxr-xr-x  3 dan dan 4096 Feb  7 20:51 .\ndrwxr-x--- 22 dan dan 4096 Feb  7 20:51 ..\n-rw-r--r--  1 dan dan    0 Feb  7 20:51 data1.csv\n-rw-r--r--  1 dan dan    0 Feb  7 20:51 data2.csv\n-rw-r--r--  1 dan dan    0 Feb  7 20:51 data3.csv\ndrwxr-xr-x  8 dan dan 4096 Feb  7 20:51 .git\n-rw-r--r--  1 dan dan   10 Feb  7 20:51 .gitignore\n-rw-r--r--  1 dan dan   15 Feb  7 20:51 README.md\n```\n:::\n:::\n\n\nGreat! Git will now ignore any file in our repository that matches the pattern\n`data*.csv`. However, it recognizes that we have introduced a new file - namely,\nthe `.gitignore` file. So we simply add `.gitignore` to the staging area and\ncommit:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add .gitignore\ngit commit -m \"added .gitignore\"\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n[main 7d1bece] added .gitignore\n 1 file changed, 1 insertion(+)\n create mode 100644 .gitignore\nOn branch main\nnothing to commit, working tree clean\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n7d1bece added .gitignore\n33276a2 initial commit\n```\n:::\n:::\n\n\n## Discard Changes\n\nLet's add a new file to our project:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho \"Hello, world!\" > file1\ncat file1\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, world!\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit add file1\ngit commit -m \"added file1\"\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n[main 337001e] added file1\n 1 file changed, 1 insertion(+)\n create mode 100644 file1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n337001e added file1\n7d1bece added .gitignore\n33276a2 initial commit\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\nnothing to commit, working tree clean\n```\n:::\n:::\n\n\nNow, this is where things start to heat up! Let's make a change to `file1`:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho \"Goodbye, world:(\" > file1\ncat file1\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nGoodbye, world:(\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   file1\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n:::\n:::\n\n\nBased on the above response from `git status`, Git is aware that `file1` has\nchanged. But, recall *staging*! This change has not yet been staged. Sometimes,\nchanges like this might occur by accident or they may no longer be desired. To\nundo *unstaged* changes to a file, use the `git checkout --` command:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncat file1\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nGoodbye, world:(\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit checkout -- file1\ncat file1\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, world!\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\nnothing to commit, working tree clean\n```\n:::\n:::\n\n\n**Voila!** Everything is back to the way it was before we changed `file1`.\n\n## Git Revert\n\nIn some cases, it will be necessary to undo an entire commit. To do so, use the\n`git revert` command and supply it with the SHA-1 hash of the commit that you\nwould like to revert. Suppose we didn't want a `.gitignore` file. We would want\nto revert our second commit:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n337001e added file1\n7d1bece added .gitignore\n33276a2 initial commit\n```\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n`<pre class=\"sourceCode bash\">\n<code class=\"sourceCode&#10;bash\"><span class=\"kw\">git</span> revert 7d1bece</code>\n</pre>`{=html}\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[main 3d77b78] Revert \"added .gitignore\"\n Date: Tue Feb 7 20:51:18 2023 -0500\n 1 file changed, 1 deletion(-)\n delete mode 100644 .gitignore\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\tdata1.csv\n\tdata2.csv\n\tdata3.csv\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n3d77b78 Revert \"added .gitignore\"\n337001e added file1\n7d1bece added .gitignore\n33276a2 initial commit\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nls -la\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ntotal 20\ndrwxr-xr-x  3 dan dan 4096 Feb  7 20:51 .\ndrwxr-x--- 22 dan dan 4096 Feb  7 20:51 ..\n-rw-r--r--  1 dan dan    0 Feb  7 20:51 data1.csv\n-rw-r--r--  1 dan dan    0 Feb  7 20:51 data2.csv\n-rw-r--r--  1 dan dan    0 Feb  7 20:51 data3.csv\n-rw-r--r--  1 dan dan   14 Feb  7 20:51 file1\ndrwxr-xr-x  8 dan dan 4096 Feb  7 20:51 .git\n-rw-r--r--  1 dan dan   15 Feb  7 20:51 README.md\n```\n:::\n:::\n\n\nRecall that the point of Git is to track ***all*** of your changes! Notice that\n`git revert` did not simply roll back or remove the specified commit. Instead,\nit created a new commit reflective of the state we desired. In fact, by removing\nour `.gitignore` file, Git is now aware of the data files that it was previously\nignoring! We can now *revert our revert* to get back our `.gitignore` file:\n\n\n::: {.cell}\n\n:::\n\n\n`<pre class=\"sourceCode bash\">\n<code class=\"sourceCode&#10;bash\"><span class=\"kw\">git</span> revert 3d77b78</code>\n</pre>`{=html}\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[main d19f5b3] Revert \"Revert \"added .gitignore\"\"\n Date: Tue Feb 7 20:51:18 2023 -0500\n 1 file changed, 1 insertion(+)\n create mode 100644 .gitignore\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit status\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nOn branch main\nnothing to commit, working tree clean\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit log --oneline\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nd19f5b3 Revert \"Revert \"added .gitignore\"\"\n3d77b78 Revert \"added .gitignore\"\n337001e added file1\n7d1bece added .gitignore\n33276a2 initial commit\n```\n:::\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nls -la\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\ntotal 24\ndrwxr-xr-x  3 dan dan 4096 Feb  7 20:51 .\ndrwxr-x--- 22 dan dan 4096 Feb  7 20:51 ..\n-rw-r--r--  1 dan dan    0 Feb  7 20:51 data1.csv\n-rw-r--r--  1 dan dan    0 Feb  7 20:51 data2.csv\n-rw-r--r--  1 dan dan    0 Feb  7 20:51 data3.csv\n-rw-r--r--  1 dan dan   14 Feb  7 20:51 file1\ndrwxr-xr-x  8 dan dan 4096 Feb  7 20:51 .git\n-rw-r--r--  1 dan dan   10 Feb  7 20:51 .gitignore\n-rw-r--r--  1 dan dan   15 Feb  7 20:51 README.md\n```\n:::\n:::\n\n\n## Closing Remarks\n\nWith just a few simple commands, you've taken your first step into a larger\nworld! The use of version control, and more specifically Git, may be a total\nparadigm shift for you. It may seem challenging to learn and difficult to\nincorporate into your everyday workflow. But over time, this will subside,\nyou'll learn to work in far more efficient ways than you did previously and Git\nwill become an indispensable tool that is integral to your approach. And we've\nonly just scratched the surface. Git's branching model is one of its key\ndifferentiators and will be next up on our list along with remote repositories,\nso stay tuned to the blog by following me on Twitter\n[\\@NegreyDan](https://twitter.com/negreydan)!\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}