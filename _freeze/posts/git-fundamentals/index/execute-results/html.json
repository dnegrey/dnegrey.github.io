{
  "hash": "82e268a7b217a9e6c17071eb86157366",
  "result": {
    "markdown": "---\ntitle: \"Git Fundamentals\"\ndate: \"2017-03-16\"\ndescription: \"This post blahblahblah.\"\ncategories: [git, command line, version control]\nimage: \"image.jpg\"\n---\n\n\nOf all the tools I use as a data scientist, the one that I cherish the most is\n**[Git](https://git-scm.com/)**. As a free and open source *distributed* version\ncontrol system, Git plays an integral role in my work by seamlessly fostering\nmany of the most important considerations of data science workflows including\n**collaboration**, **experimentation**, **reproducibility** and of course,\n**source code management**.\n\nAt their core, version control systems (VCS) all serve one broad and common\npurpose: *tracking changes to files*. What distinguishes one system from\nanother, however, is *how* that purpose is implemented and what additional\nfeatures are present. To get a better understanding of the history and evolution\nof version control systems, I recommend reading the introduction at [Ry's Git\nTutorial](http://rypress.com/tutorials/git/index). You might also want to\nbookmark his tutorial and work your way through all of the sections as he does a\nterrific job demonstrating Git's feature set in much greater detail than what\nI'm covering in this post.\n\nBefore we move on, let's clarify something that often comes up when people first\nstart learning about Git. Many of you may have heard of companies like\n[GitHub](https://github.com/), [GitLab](https://about.gitlab.com/) or\n[Bitbucket](https://bitbucket.org/). These are each examples of *web-based\nrepository hosting services*. Git itself is just a lightweight command line\ntool. Services like GitHub provide software development platforms that center\naround the use of Git but add a rich suite of additional features. The focus of\nthis post is on learning the fundamentals of the Git command line tool.\n\n## Prerequisites\n\nA basic understanding of Linux (Unix-like) commands is assumed. Specifically,\nthis post makes extensive use of the following:\n\n* `mkdir`: create new directories\n* `cd`: change the current working directory\n* `echo`: display a line of text\n* `cat`: concatenate files and print on the standard output\n* `ls`: list directory contents\n* `rm`: remove files or directories\n\nFor brevity, I am using `echo` with redirection (`>`) to write files. In\nreality, you'd be using a visual editor such as `vi` to write and edit files.\n\n## Create a Local Git Repository\n\nBefore we can do anything with Git, we must initialize a directory as a Git\nrepository. Let's do so in a brand new directory that we'll create called\n`fundamentals` underneath our home directory (`~`):\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd ~\nmkdir fundamentals\ncd fundamentals\ngit init\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\nInitialized empty Git repository in /home/dan/fundamentals/.git/\n```\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n## Add a README File\n\nThe first thing you'll want to do with any new Git repository is add a\n**README.md** file to the project root. As a plain text file, it will be the\neasiest place to save and read notes about your project. The \".md\" extension\nindicates that it is a [markdown](https://daringfireball.net/projects/markdown/)\nfile. Markdown is a text-to-HTML conversion tool that allows you to create\neasy-to-read and easy-to-write plain text files which get converted to HTML.\nHosting services like GitHub and GitLab will automatically render your README.md\nfile to HTML at the main repository site (for example:\n[https://github.com/rstudio/blogdown](https://github.com/rstudio/blogdown)).\nHere is a brief primer on some of the more commonly used markdown syntax:\n\n----------\n\n<div>\n<div style=\"float: left; width: 48%; margin-left: 0; margin-right: 2%;\">\n\n### **Headers**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# is an h1 header\n## is an h2 header\n### is an h3 header (and so on)\n```\n:::\n\n\n### **Regular Writing**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nRegular writing becomes a <p> tag\n```\n:::\n\n\n### **Inline Code**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nEnclose inline code in `single ticks`\n```\n:::\n\n\n### **Unordered Lists**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n* item one in unordered list\n* item two in unordered list\n* item three in unordered list\n```\n:::\n\n\n</div>\n<div style=\"float: right; width: 48%; margin-left: 2%; margin-right: 0;\">\n\n### **Italics and Bold**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n*italics*\n**bold**\n***bold-and-italics***\n```\n:::\n\n\n### **Hyperlinks**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n[hyperlink-alt-text](hyperlink-href)\n```\n:::\n\n\n### **Code Chunks**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n    Indent four spaces for a code block\n```\n:::\n\n\n### **Ordered Lists**\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n1 item one in ordered list\n2 item two in ordered list\n3 item three in ordered list\n```\n:::\n\n\n</div>\n<br style=\"clear:both;\"/>\n</div>\n\n----------\n\nNow let's actually create our README.md file. A popular convention (and one that\nI use) is to have the first line of your README.md file be an `<h1>` header with\nthe name of your repository:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\necho \\# fundamentals > README.md\ncat README.md\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n# fundamentals\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}